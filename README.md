# Home Lab Easy Kit
![Home Lab Easy Kit](doxygen/images/logo.png)

[TOC]

## Description

This project allows to use some STM32F103C8T6 peripherals with Linux based microcomputers like Raspberry Pi using I2C bus.

Purpose for Home Lab Easy Kit project is to give amateurs possibility to build experimental setups easier and to save time for other more important objectives like experiment logic, calculations, etc. Efficiency is achieved by generated firmware for well known, cheap and accessible STM32F103C8T6 micro controller (MCU). There are number of boards accessible on the market which may be also referred as "Blue pill". This project allows linkage with generated C++ library that implements communication with micro controller and provide simple interfaces to MCU peripherals.

There are number of benefits provided by this solution:
- Logic and heavy calculations may be moved from micro controller to computer, which performance is generally much better.
- It is possible to use other libraries for database access, data science, networking etc.\
- Communication utilizes I2C in 8 bit addressing mode. In theory you can connect up to 256 micro controllers to single I2C port.
- Firmware architecture is intended to use MCU peripherals economically to allow as much peripherals to be used per micro controller as possible.

For sure, user should have some theoretical and practical background related to micro controllers, electronics and what he is doing. Home Lab Easy Kit doesn't void this requirement, it just makes entrance easier and allows to save time.

## Key components

Project consist of three parts: Customizer, Firmware and Software.

`JSON configuration file` is written by user to describe peripherals to be used and configure them. This file describes user requirements to customizer and allows to generate software and firmware sources to meet user expectations.

`Customizer` generate C and C++ headers required for firmware and software parts. Also customizer is capable to detect some issues in JSON configuration and to warn user.

`Firmware` part is CMSIS based project written on C. Once headers are generated by customizer it may be compiled and flashed into MCU. User is not required to change firmware sources, however it is not forbidden.

`Software` part consist of C++ library based on JSON configuration file provided to Customizer. Also, there is monitor tool linked with this library that can be used to test software to firmware communication and firmware peripherals being used.

`Documentation` Documentation is split onto three parts.
- This document serves as introduction. Also it explains basic things like software and hardware requirements, JSON configuration file, etc.
- Software documentation is provided in doxygen form. It should be generated in order to get more information on classes, interfaces, etc. It is required if you plan to use this project.
- Firmware documentation is also provided in doxygen form. It is optional and incomplete. Someone, curious, may use it to understand how firmware works.

## Hardware requirements
- Computer or microcomputer with Linux and possibility to connect and work with I2C bus. Software implementations of I2C bus also should work. Note, I2C will not be used in clock stretching mode. It means all Raspberry Pi versions may be used (I2C stretching bug in BCM2835 processor shouldn't be a barrier)
- STM32F103C8T6 micro controller. It may be one of "Blue pill" boards or self made PCB with this micro controller.
- STM32 ST-LINK v2 programmer or any other capable to work with STM32F103C8T6.
- Power supply capable to provide as much power as your project require. Prefer power supplies with ground line. Avoid using two or more power supplies in your project, this may cause serious issues.

## Software requirements
It is possible to use either micro computer or PC as building machine. Technically you don’t need separate computer and may work on microcomputer, however good PC with Linux seems to be better option.

The following packages are used by Home Lab Easy Kit project:
- `CMake`: With version >= 3.10
- `ICU4C`: Unicode support. It is required on computer to build software part only. For Raspbian Buster install libicu-dev.
- `GNU ARM Toolchain`: It is required to build firmware only. For Raspbian Buster the following packages may be installed: binutils-arm-none-eabi, gcc-arm-none-eabi, gdb-multiarch. Note, user should modify firmware/toolchain.cmake in order to configure toolchain for CMake.
- `STM32F10x Standard Peripherals Library`: It is required to build firmware only. Unpack library and modify STDPERIF_PATH variable in firmware/toolchain.cmake. It can be downloaded from [ST web site](#http://www.st.com/st-web-ui/static/active/en/st_prod_software_internet/resource/technical/software/firmware/stsw-stm32054.zip). It is possible to get “registers may not be the same” compilation errors with this library. If the error appears use [patch](#https://gist.github.com/timbrom/1942280) to fix it.
- `OpenOCD`: This software is required to flash and debug firmware. For Raspbian Buster the following packages may be installed: openocd
- `ST-LINK/V2 tools`: This software is required to flash and debug firmware. For Raspbian Buster the following packages may be installed: stlink-tools
- `i2c-tools`: are very useful during work with i2c bus.
- `doxygen`: Doxygen is required to generate documentaion for firmware and software parts of the project.
- `python3`: Customizer is written with Python3, which is required to customize project.

## Usage instructions

Note, this project doesn't describe electrical connections, it main goal to provide firmware and software

List below describes sequential actions required to start:
1. Install software dependencies.
2. Prepare JSON configuration file.
3. Run customizer with JSON configuration file passed as parameter.
4. Build firmware and flash MCU.
5. Build software and link generated library to your project.
6. Make all electrical connections for your project.

## Available peripherals

Currently Home Lab Easy Kit support the following functionalities that represent peripherals available on STM32F103C8T6:
| Name      | Description | Exclusive |
|:----------|:------------|:---------:|
| INFODev | Firmware identification and information support | Yes |
| ADCDev | 12-bit Analogue to Digital Converter support | No |
| DESKDev | Simple set of four buttons and one encoder | Yes |
| GPIODev | General purpose input/output support | Yes |
| IRRCDev | NEC standard IR remote control support | Yes |
| LCD1602ADev | Simple LCD1602a screen support | Yes |
| RTCDev | Real Time Clock support | Yes |
| SPWMDev | Multichannel software PWM support | Yes |
| StepMotorDev | Support for A4998 and DRV8825 stepper motor drivers | No |
| UARTDev | UART proxy ( allow to communicate with UART devices connected to micro controller ) | No |

Exclusive feature means that this feature may be enabled in a form of single virtual device. Non-exclusive features may provide several virtual devices of similar functionality but using different peripherals and working independently.

## JSON configuration file

JSON configuration file has the following structure:

```
{
    "firmware" : {
        "mcu_model" : "stm32f103",
        "device_name" : "raspi_extender",
        "i2c_bus" : {
            "clock_speed" : 100000,
            "buffer_size" : 512,
            "address" : 32,
            "requires" :  {"i2c" : "I2C2"}
        }
    },
    "devices" : {
        "DeskDevCustomizer" : { ... },
        "RTCCustomizer" : { ... },
        "IRRCCustomizer" : { ... },
        "UartProxyCustomizer" : { ... },
        "LCD1602aCustomizer" : { ... },
        "GPIODevCustomizer": { ... },
        "SPWMCustomizer": { ... },
        "ADCDevCustomizer": { ... },
        "StepMotorDevCustomizer": { ... }
    }
}
```

The first `firmware` key describes basic firmware properties.
| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"mcu_model"` | MCU model being used, currently the only MCU is supported | "stm32f103" | Yes |
| `"device_name"` | Name of the firmware represented by this JSON file | reasonable name in quotes | Yes |
| `"i2c_bus"` | Describes i2c connection with micro computer and MCU. | Object, see below | Yes |
| `"clock_speed"` | I2C bus clock speed. This project was tested with standard frequency only (100kHz) | 100000 | Yes |
| `"buffer_size"` | Size of the buffer for commands being sent from microcomputer to MCU, in bytes. | Number | Yes |
| `"address"` | I2C bus address. Must be valid 8-bit i2c bus address for your project. | Number | Yes |
| `"requires"` | This object, here and after contain description of peripherals required. | Object | Yes |
| `"i2c"` | Represents I2C peripherals being used for communication | "I2C1" or "I2C2" | Yes |
| `"devices"` | Describes required functionalities. | Object | Yes |

Each functionality is represented by corresponding key/object pair under `devices` key. The only exception is INFODev - it is not described in JSON file at all and is generated automatically based on information provided. Each key under `devices` must have one of these values: `"DeskDevCustomizer"`, `"RTCCustomizer"`, `"IRRCCustomizer"`, `"UartProxyCustomizer"`, `"LCD1602aCustomizer"`, `"GPIODevCustomizer"`, `"SPWMCustomizer"`, `"ADCDevCustomizer"`, `"StepMotorDevCustomizer"`. Internally they are called as customizers, to reflect their ability to customize firmware and software.

Each of these keys should have one or more key/object pairs, where key is a "name" of the device and object describes device itself. Exclusive features may be represented by single device only, non-exclusive features may have more devices described. Presence of all features is not required, so leave those customizers which are required for your project.

Note, `"firmware"` doesn't allow to select MCU frequency. For example, STM32F10x is configured to use 72MHz clock and it's not possible to change. Table below shows some important settings that can't be changed by JSON configuration file.

| Parameter  | Description                            | Value  |
|:-----------|:---------------------------------------|:-------|
|$$F_{mcu}$$   | MCU frequency                          | 72 MHz |
|$$F_{gpio}$$  | Maximum output frequency               | 50 MHz |
|$$D_{AHB}$$| AHB clock divider                         | 1      |
|$$D_{APB1}$$| APB1 clock divider                        | 2      |
|$$D_{APB2}$$| APB2 clock divider                        | 1      |


### Peripherals

Most of the features require some peripherals from MCU. Such dependencies are described as JSON object with key equal to peripheral type and value with name of the peripheral. Most of the time name is the same as how peripheral is defined in CMSIS library. Table below describes details about peripherals types, possible values, etc.

#### Peripherals types table
| Key (Type) | Description | Possible values (for STM32F103C8T6) |
|:-----------|:------------|:------------------------------------|
|`"i2c"`| I2C interface. Currently is used for communication with software only. |"I2C1" or "I2C2" |
|`"gpio"`| General purposes input/output pin. | "PA_0" ... "PA_15", "PB_0" ... "PB_15", "PC_13" ... "PC_15"|
|`"bkp"`| Backup register | "BKP_DR1" ... "BKP_DR42"|
|`"rtc"`| Real time clock | "RTC"|
|`"timer"`| Timer[^1] | "TIM1" ... "TIM17"|
|`"adc"`| Analog to digital converter | "ADC1" or "ADC2"[^2]|
|`"adc_input"`| Analog to digital converter input |"ADC_Channel_0" ... "ADC_Channel_9", "ADC_Channel_TempSensor", "ADC_Channel_Vrefint"|
|`"usart"`| USART interface | "USART1", "USART2", "USART3"|


The following table describes pin configurations available in STM32F103x. It is general across many electronic devices, however values are taken from CMSIS library.

#### GPIO pin configuration table
| Value | Direction | Description |
|:------|:----------|:------------|
|`"GPIO_Mode_IN_FLOATING"`| Input  | Pin is floating
|`"GPIO_Mode_IPU"`        | Input  | Pin is pulled up to VCC
|`"GPIO_Mode_IPD"`        | Input  | Pin is pilled down to GND
|`"GPIO_Mode_Out_OD"`     | Output | Open drain
|`"GPIO_Mode_Out_PP"`     | Output | Push pull

Be very careful with logic levels. Some STM32F103C8T6 are 5v tolerant, some not. Improper electrical connection may cause a lot of harm. If doubt, refer documentation provided by manufacturer.

The table below describes ADC inputs available in STM32F103C8T6.

#### ADC input table
| Value | Description | Corresponding GPIO pin | May be used with |
|:------|:------------|:-----------------------|:-----------------|
|`"ADC_Channel_0"`| ADC input 0 | "PA_0" | "ADC1" or "ADC2" |
|`"ADC_Channel_1"`| ADC input 1 | "PA_1" | "ADC1" or "ADC2" |
|`"ADC_Channel_2"`| ADC input 2 | "PA_2" | "ADC1" or "ADC2" |
|`"ADC_Channel_3"`| ADC input 3 | "PA_3" | "ADC1" or "ADC2" |
|`"ADC_Channel_4"`| ADC input 4 | "PA_4" | "ADC1" or "ADC2" |
|`"ADC_Channel_5"`| ADC input 5 | "PA_5" | "ADC1" or "ADC2" |
|`"ADC_Channel_6"`| ADC input 6 | "PA_6" | "ADC1" or "ADC2" |
|`"ADC_Channel_7"`| ADC input 7 | "PA_7" | "ADC1" or "ADC2" |
|`"ADC_Channel_8"`| ADC input 8 | "PB_0" | "ADC1" or "ADC2" |
|`"ADC_Channel_9"`| ADC input 9 | "PB_1" | "ADC1" or "ADC2" |
|`"ADC_Channel_Vrefint"`| Internal Vref voltage |  | "ADC1" |
|`"ADC_Channel_TempSensor"`| Internal temperature sensor |  | "ADC1" |

STM32F10x introduces successive approximation analog-to-digital converters, therefore it's important to control sampling time. In a few words: measurement consist of two phases: sampling and conversion. Sampling charges internal sample and hold circuit capacitors.  Once sampling is done, conversion does actual conversion of sampled voltage into digital value. Table below describes sampling times constants available for STM32F10x.

Sampling requires some current from input. Improperly configured inputs connected to high impedance outputs may undercharge sampling and hold capacitors and additional measurement error will appear. Sampling time values are specified in MCU cycles and correspond to the ones available in CMSIS library:

#### ADC sampling times
| Value                       | Description  |
|:----------------------------|:-------------|
|`"ADC_SampleTime_1Cycles5"`  | 1.5 cycles   |
|`"ADC_SampleTime_7Cycles5"`  | 7.5 cycles   |
|`"ADC_SampleTime_13Cycles5"` | 13.5 cycles  |
|`"ADC_SampleTime_28Cycles5"` | 28.5 cycles  |
|`"ADC_SampleTime_41Cycles5"` | 41.5 cycles  |
|`"ADC_SampleTime_55Cycles5"` | 55.5 cycles  |
|`"ADC_SampleTime_71Cycles5"` | 71.5 cycles  |
|`"ADC_SampleTime_239Cycles5"`| 239.5 cycles |

[^1]:STM32 describes several timer types with different features and possibilities. Some features of Home Lab Easy Kit may require some specific timers. In this case it will be stated separately.
[^2]: Some other MCU from STM32F10x family may have ADC3 onboard. To use it light modification of customizer/stm32f103.py is required.

### DeskDevCustomizer
DESKDev is a virtual device with four buttons for "up", "down", "left", "right" and one encoder. It's purpose to organized very simple menu control in conjunction with LCD1602ADev. Example JSON configuration for `DeskDevCustomizer` key describing DESKDev is given below.

```
"DeskDevCustomizer" : {
    "controls" : {
        "dev_id" : 1,
        "requires" : {  
            "up"      : { "gpio" : "PA_3" },
            "down"    : { "gpio" : "PA_2" },
            "left"    : { "gpio" : "PA_5" },
            "right"   : { "gpio" : "PA_4" },
            "encoder" : {
                "A" : { "gpio" : "PA_7"},
                "B" : {"gpio" : "PA_6"}
            }
       }
  }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"dev_id"` | Device id | Number, from 1 to 16 | Yes |
| `"requires"` | This object contain description of peripherals required. | Object | Yes |
| `"up"` | GPIO pin for "up" button | `"gpio"` | Yes |
| `"down"` | GPIO pin for "down" button | `"gpio"` | Yes |
| `"left"` | GPIO pin for "left" button | `"gpio"` | Yes |
| `"right"` | GPIO pin for "right" button | `"gpio"` | Yes |
| `"A"` | GPIO pin for "A" line of the encoder | `"gpio"` | Yes |
| `"B"` | GPIO pin for "B" line of the encoder | `"gpio"` | Yes |


All buttons must be normally opened, so when corresponding button is pushed (pin is pulled up), MCU will trigger an external interrupt. One button terminal must be connected to the corresponding pin, another terminal should be grounded.

### RTCCustomizer

RTCDev is a virtual device that provides access to the STM32F103C8T6 real time clock. This is very useful especially when micro computer doesn't have real time clock on a board. This might be an issue if no internet access is available and computer may be powered down periodically for some reason.

Example JSON configuration is given below:
```
"RTCCustomizer" : {
  "rtc": {
      "dev_id": 2,
      "requires": { "bkp" : "BKP_DR1",
                    "rtc" : "RTC"}
  }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"requires"` | This object contain description of peripherals required. | Object | Yes |
| `"bkp"` | Backup register to be used | `"bkp"` | Yes |
| `"rtc"` | RTC to be used | `"rtc"` | Yes |


### IRRCCustomizer

IRRCDev virtual device allows to control your experimental build with IR remote controller. It must use NEC standard. This will allow you to give control your experiments from short distance, from sofa for example.

Example JSON configuration for IRRCDev:

```
"IRRCCustomizer" : {
    "irrc": {
        "dev_id": 3,
        "buffer_size" : 64,
        "requires": {"data" : {"gpio" : "PA_1"}}
    }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"buffer_size"` | Size of the circular buffer to store IR remote control commands, in bytes | Number, must be even | Yes |
| `"requires"` | This object contain description of peripherals required. | Object | Yes |
| `"data"` | Describes data input. Must contain `"gpio"` dependency. | `"gpio"` | Yes |

There are wide spectrum of special three terminal devices (like TSOP384 series) to handle IR remote controllers optical signals. One of these, or equivalent must be connected to data pin in order to make this functionality working. Note, this device must correspond to your IR remote controller frequency.


### LCD1602aCustomizer

LCD1602ADev	virtual device allows to use simple LCD to display some short information, messages or notifications. This feature is used in conjunction with LCD1602a screens which are cheap and widely present on the market. This screen is used in 4 bit data mode to save GPIO lines. Back-light support is available as well.

```
"LCD1602aCustomizer" : {
    "lcd": {
        "dev_id" : 5,
        "wellcome" : ["-=RPi Extender=-","   loading ..."],
        "requires" : {"enable" : {"gpio" : "PB_14"},
                      "reg_sel" : {"gpio" : "PB_13"},
                      "data4" : {"gpio" : "PB_6"},
                      "data5" : {"gpio" : "PB_7"},
                      "data6" : {"gpio" : "PB_8"},
                      "data7" : {"gpio" : "PB_9"},
                      "light" : {"gpio" : "PB_0"}
        }
    }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"wellcome"` | Array with two strings. First string is default top line text, second string is default bottom line text.| Array with two strings | Yes
| `"requires"` | This object contain description of peripherals required. | Object | Yes |
| `"enable"` | GPIO pin for enable signal | `"gpio"` | Yes |
| `"reg_sel"` |  GPIO pin for Instruction/Data Register Selection signal | `"gpio"` | Yes |
| `"data4"` | GPIO pin for data 4 signal | `"gpio"` | Yes |
| `"data5"` | GPIO pin for data 5 signal | `"gpio"` | Yes |
| `"data6"` | GPIO pin for data 6 signal | `"gpio"` | Yes |
| `"data7"` | GPIO pin for data 7 signal | `"gpio"` | Yes |
| `"light"` | GPIO pin for back light signal | `"gpio"` | Yes |

### UartProxyCustomizer

STM32F103C8T6 has three USART interfaces. UARTDev virtual device feature add possibility to use these interfaces to connected different UART devices.

```
"UartProxyCustomizer" : {
    "uart_proxy_0" : {
        "dev_id" : 4,
        "hint" : "gsmmodem",
        "buffer_size" : 2000,
        "baud_rate" : 9600,
        "requires" : { "usart" : "USART1"}
    }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"uart_proxy_0"` | Name of the UARTDev virtual device. | String | Yes |
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"hint"` | Optional hint, specifies which device is connected | "gsmmodem" | No |
| `"buffer_size"` | Size of the receive device buffer, in bytes | Number | Yes |
| `"baud_rate"` | Baud speed of communications | Number | Yes  |
| `"requires"` | This object contain description of peripherals required. Must has dependency to `"usart"` interface. | Object | Yes |

Note, this feature use two lines only: RX and TX. Other lines available for USART interfaces are not used.

### GPIODevCustomizer

GPIODev virtual device makes possible to control specific MCU pins. It's possible to use them as inputs and outputs. Other pin configurations are also available. Each pin has a name, which is a key for description objects specified in `"description"`. Pins are configured during project customization, and can't be reconfigured later in run time. Example below lists two pins, one for input and one for output.

```
"GPIODevCustomizer": {
    "gpio" : {
        "dev_id": 6,
        "description" : {
            "in_0": {  "type" : "GPIO_Mode_IPU",
                       "gpio" : "PA_11"
            },
            "out_1": { "type" : "GPIO_Mode_Out_PP",
                       "gpio": "PC_13",
                       "default": "1"
            }
        }
    }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"description"` | This object contain descriptions of pins for this virtual device | Object | Yes |
| `"in_0"` and `"out_1"` | These objects contain descriptions of pins they represent | Object | Yes |
| `"type"` | Pin configuration | [Pin configuration](#GPIO-pin-configuration-table) | Yes |
| `"gpio"` | Dependency to gpio pin | `"gpio"` | Yes |
| `"default"` | Specifies default state for output pins. | 0 or 1 | Required for outputs, has no effect for inputs |

### SPWMCustomizer
SPWMDev provides software PWM. It means that hardware PWM is not used, because of less flexible pin usage. This implementation use just one timer, and is capable to utilize all gpio outputs. However there is a price: hardware implementation is more accurate, stable, reliable and wont spent execution time in interrupt handler. Use it if you need something that doesn't require all the benefits of hardware PWM.

```
"SPWMCustomizer": {
    "spwm" : {
        "dev_id" : 7,
        "prescaler" : 21,
        "description" : {
            "L0" : {
                "type" : "GPIO_Mode_Out_PP",
                "gpio" : "PB_1",
                "default" : 1
            }
        },
        "requires" :  {"timer" :  "TIM4"}
    }
}
```
| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"description"` | This object contain descriptions of SPWMDev outputs | Object | Yes |
| `"prescaler"` | Timer prescaller value (see below) | Number | Yes |
| `"L0"` | Name of the output. Object that stores description for this specific output. | Object | Yes |
| `"type"` | Output pin configuration. May not be input! | [Pin configuration](#GPIO-pin-configuration-table) | Yes |
| `"gpio"` | GPIO pin to be used as output | `"gpio"` | Yes
| `"default"` | Default value for the output. Default values may be either on or off| 0 or 1 | Yes |
| `"requires"` | This object contain timer description to be used by SPWMDev. | Object | Yes |

`"Prescaller"` specifies divider for timer clock. Greater values allow to get longer PWM pulse duration, lower values decrease it. Timer counter clock frequency is described by the formula:

$$ F_{cnt} = \dfrac{F_{t}}{prescaler + 1} $$

Where <img src="https://render.githubusercontent.com/render/math?math=F_{cnt}"> is a counter clock frequency, <img src="https://render.githubusercontent.com/render/math?math=F_{t}"> source timer clock, which is set in this project equal to the maximum MCU frequency <img src="https://render.githubusercontent.com/render/math?math=F_{mcu}=72MHz">. In this case prescaller is 1, therefore counter clock frequency is <img src="https://render.githubusercontent.com/render/math?math=F_{cnt}=36MHz">. Refer to MCU datasheet in order to get more information regarding timer clocking.

Note, `"default"` value doesn't allow to set something between on and off. This is made intentionally to protect hardware from possible mistakes (like unintentional MCU reset).

Example:

Let's say there is BLDC motor from old HDD and ESC motor driver which is regulated with PWM. The goal is to control motor from software. Most of the ESC drivers require PWM pulse frequency equal to 50Hz. The formula above may be transformed as:

$$prescaller = \dfrac{F_{t}}{65536\cdot F_{pwm}}-1$$

where <img src="https://render.githubusercontent.com/render/math?math=F_{pwm}=50Hz">, <img src="https://render.githubusercontent.com/render/math?math=F_{t}=72MHz">. In this case <img src="https://render.githubusercontent.com/render/math?math=prescaller=21">.
Note, many ESC motor drivers require 5V PWM pulses, however STM32F103x produce 3.2V pulses, so some logical level conversion is required in this case.


### ADCDevCustomizer

ADCDev virtual device establish simple access to 12-bit ADC peripherals available in STM32F10x. STM32F103C8T6 has two ADC, both of them may be used. ADC may be used in either interrupt or DMA (Direct Memory Access) mode. Current implementation doesn't give as much performance benefits as DMA may provide. This functionality shouldn't be treated as a kind of oscilloscope for quick signal measurements. Instead of this, feature is designed to be multichannel multimeter, capable to provide data logging for slow signals. STM32F10x also allows to measure internal temperature and internal reference voltage. For fast signals it is better to consider some specialized hardware.

```
"ADCDevCustomizer": {
    "adc_0" : {
        "dev_id" : 8,
        "buffer_size" : 96,
        "use_dma" : 1,
        "vref" : 3.2,
        "sample_time" : {
            "default" : "ADC_SampleTime_7Cycles5",
            "override" :  {"input_0" : "ADC_SampleTime_28Cycles5"}
        },
        "requires" :  {
            "ADC" : {"adc" : "ADC1"},
            "TIMER" : {"timer" :  "TIM2"},
            "input_0" : {"adc_input" : "ADC_Channel_0"},            
            "input_vref" : {"adc_input" : "ADC_Channel_Vrefint"},
            "input_temp" : {"adc_input" : "ADC_Channel_TempSensor"}
        }
    }
}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"adc_0"` | Name of the ADCDev virtual device. | String | Yes |
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"buffer_size"` | Size of the internal circular buffer. It is recommended to be multiple to the number of inputs.|  Number | Yes |
| `"use_dma"` | Instructs to use either DMA (1) or interrupt mode (0) | 0, 1 | Yes |
| `"vref"` | Reference voltage, used by software to return measurements in volts. Specify voltage that correspond to maximum ADC value[^3]. | Value in volts | Yes |
| `"sample_time"` | This object specifies sample timings for inputs. Values correspond to the ones used by CMSIS library. | Object | Yes |
| `"default"` | Default sampling time for all inputs. |  [Sampling time](#ADC-input-table) | Yes |
| `"override"` |Contains input name/sampling times to override default sample time for some inputs. | Input name/[Sampling time](#ADC-input-table) | Yes |
| `"requires"` | This object contain peripherals and inputs required by ADCDev. | Object | Yes |
| `"ADC"` | Object holding ADC peripheral used with this virtual device. Key value ("ADC") may be changed. | Object with `"adc"` | Yes |
| `"TIMER"` | Object holding timer to be used with this virtual device. Timer is required for both interrupt and DMA mode. Key value ("TIMER") may be changed.| Object with `"timer"` | Yes |
| `"input_0"` | Object holding ADC input. Key value ("input_0") specifies input name and is used in software. | Object with `"adc_input"` | No |
| `"input_vref"` | Object holding ADC internal Vref input. Key value ("input_vref") specifies input name and is used in software. | Object with `"adc_input"` | No |
| `"input_temp"` | Object holding ADC internal temperature sensor input. Key value ("input_temp") specifies input name and is used in software. | Object with `"adc_input"` | No |


[^3]: "Blue Pill" goes in LQFP48 package. These MCU has <img src="https://render.githubusercontent.com/render/math?math=V_{ref%2B}"> connected to <img src="https://render.githubusercontent.com/render/math?math=V_{DDA}"> internally (<img src="https://render.githubusercontent.com/render/math?math=V_{ref-}"> is connected to the <img src="https://render.githubusercontent.com/render/math?math=V_{SSA}">). In this case you have to specify <img src="https://render.githubusercontent.com/render/math?math=V_{DDA}"> voltage. Also, you may use `"ADC_Channel_Vrefint"` channel to measure reference voltage and to calculate <img src="https://render.githubusercontent.com/render/math?math=V_{DDA}">. Read more details in corresponding documentation provided by manufacturer

### StepMotorDevCustomizer

StepMotorDev provides stepper motor drivers support. Currently A4998 and DRV8825 are supported. These drivers are cheap and widely present on the market. A4998 and DRV8825 are very similar, however they have differences like fault in DRV8825 pin that allows to detect driver failure. Also this feature support logic for two endstops (hardware and software), logic for motor driver failure line, micro steps. Each stepper motor has it's own buffer for the stepper motor commands. If several motors are customized for the same virtual device, all these commands will be executed synchronously, thus stepper motor movements will be synchronized.

Supported stepper motor drivers provide a significant amount of signal lines, most of them are optional. In order to make this feature to be as flexible as possible there is just one mandatory signal that requires gpio - `STEP`. All other lines are optional.

Be very careful with stepper motors. These devices consume significant current and may cause burns or fire if incorrectly connected or misused.

```
"StepMotorDevCustomizer": {
    "motor_group_1" : {
        "dev_id" : 9,
        "motors" : {
            "m0" : {
                "buffer_size" : 512,
                "steps_per_revolution" : 200,
                "drive_type" : "a4998",
                "default_speed" : 10000,
                "error_action" : "stop",
                "step"  : {"gpio" :  "PA_0"},
                "dir"   : {"default" : "CW"},
                "m1"   : {"default" : 0},
                "m2"   : {"default" : 0},
                "m3"   : {"default" : 0},
                "enable": {"default" : "disable"},
                "sleep" : {"default" : "wakeup"},
                "cw_endstop" : {"position_limit" : "20000", "active_level" :  "low", "action": "ignore"},
                "ccw_endstop" : {"position_limit" :  "-20000", "active_level" :  "high", "action": "ignore"}
            }
        },
    "requires" :  { "timer" : "TIM3"}}}
```

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"motor_group_1"` | Virtual device name | String | Yes |
| `"dev_id"` | Device id | Number, [1, 15] | Yes |
| `"motors"` | Object that contains motors to be described | Object | Yes |
| `"m0"` | Object that contains "m0" motor description | Object | Yes |
| `"buffer_size"` |  Motor circular buffer size in bytes | Number | Yes |
| `"steps_per_revolution"` | Motor steps per revolution value. Refer to stepper motor documentation. | Number | Yes |
| `"default_speed"` | Default motor speed. It is a number of microseconds between step pulses. It doesn't take into account micro stepping. | Number | Yes |
| `"drive_type"` | Type of the driver being used. | "drv8825", "a4998", "unknown" | Yes |
| `"error_action"` | Action to be made on error. "stop" will stop just this motor. "stop_all" will stop all motors in the virtual device. | "stop", "stop_all" | Yes |
| `"step"` | Describes gpio pin to be used for `STEP` signal. | Object with `"gpio"` | Yes |
| `"dir"` | Object that describe stepper motor default `DIR` and signal. [Details here...](#Stepper-motor-direction)| Object | Yes |
| `"m1"`, `"m2"`, `"m3"` | Objects that describe micro step pins and default values. [Details here...](#Micro-stepping)| Object | Yes |
| `"enable"` | Object that describe enable signal and default enable state. [Details here...](#Enable)| Object | Yes |
| `"sleep"` | Object that describe sleep signal and default sleep state. [Details here...](#Sleep)| Object | Yes |
| `"fault"` | Object that control fault behavior. Available for DRV8825 and "unknown" drivers. [Details here...](#Fault)| Object | No |
| `"cw_endstop"` | Object that describe clock-wise end stop. [Details here...](#End-stops)| Object | Yes |
| `"ccw_endstop"` | Object that describe counter-clock-wise end stop. [Details here...](#End-stops)| Object | Yes |
| `"requires"` | Object that describes peripherals required by the virtual device. Just one timer is required per virtual device. | Object with `"timer"` | Yes |

#### Stepper motor direction
Stepper motor direction may be clock-wise or counter-clock-wise. Optionally it may specify `DIR` pin for supported stepper motor drivers.

Table below describe key/values to customize stepper motor direction:
| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"default"` | Default stepper motor direction | "CW" for clock-wise, "CCW" for counter-clock-wise | Yes |
| `"gpio"` | Optional GPIO pin dedicated for `DIR` signal. | `"gpio"` | No |

Actual direction values are very related, user should define what is "clock-wise" and "counter-clock_wise" for stepper being used.



#### Micro stepping
A4998 and DRV8825 use micro stepping lines in order to do micro steps ( a fraction of single step motor step ). User may either change these lines from software, or pull up or down these pins if micro steps are not required. In any case stepper motor logic implemented in firmware and software must be aware of micro steps being used. It directly impacts on stepper motor position being calculated during movement. Table below describes values to be used by `"m1"`, `"m2"`, `"m3"`.

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"default"` | Value that describe default micro step line value. | 0 or 1| Yes|
| `"gpio"` | Optional GPIO pin dedicated for corresponding stepper motor line. | `"gpio"`| No |

It is possible to use GPIO pins for some of these lines, while others has no GPIO pins assigned.

#### Enable

`ENABLE` line allows to enable/disable stepper motor driver. Table below describes values available for `"enable"` key.

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"default"` | Default enable value | "enable" or "disable"| Yes |
| `"gpio"` | Optional GPIO pin used to control this line | `"gpio"`| No |

Note, that stepper motor left enabled will consume significant current and may overheat. It is not recommended to set stepper motor `"default"` value to "enable".

#### Sleep

`SLEEP` signal may put driver into sleep mode. Table below describes values for `"sleep"` key:

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"default"` | Default sleep pin value | "sleep" or "wakeup"| Yes |
| `"gpio"` | Optional GPIO pin dedicated for the `SLEEP` line. | `"gpio"`| No |

#### End stops

End stops provide possibility to stop stepper motor when it reached some limit. Such limit may be defined by hardware by using end stop switch for example, or by software limitation. In the case of software limitation current motor position calculated by firmware is being used. Table below explains values available for both clock-wise and counter-clock-wise end stop description:

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"action"` | Action that happens when end-stop is triggered. It is possible to "ignore" it, "stop" the motor or "stop_all" motors. | "ignore", "stop", "stop_all" | Yes |
| `"position_limit"` | Mandatory if gpio pin is not dedicated for hardware end stop. Specify stepper motor position where stepper motor software limit will be triggered. | Number | Yes, if `"gpio"` is not used |
| `"gpio"` | Hardware end stop is used. Specifies GPIO pin to be used for this purpose. | `"gpio"` | No |
| `"active_level"` | Active logical level that makes hardware end stop active. | "low" or "high" | Yes, if `"gpio"` is used |

Firmware calculates postion for each stepper motor used. Position is being calculated by the following formula: <img src="https://render.githubusercontent.com/render/math?math=P=32\times N">, where <img src="https://render.githubusercontent.com/render/math?math=P"> is current position, <img src="https://render.githubusercontent.com/render/math?math=N"> number of full steps performed, 32 is a minimal fraction of step supported by micro stepping. If motor direction is clock-wise <img src="https://render.githubusercontent.com/render/math?math=P"> increases, if direction is counter-clock-wise decrease. For example, if stepper motor executes two subsequent commands to move by one counter-clock-wise and current micro stepping option will instruct to do half-step, than position will decrease by one.

If `"driver_type"` is "unknown" micro stepping is not supported and motor position will change by full step every `STEP` pulse.

#### Fault

DRV8825 is different to A4998. It has "Fault" line that may be used to detect fault conditions inside driver. Table below explains possible values to use it:

| Key      | Value description | Possible values | Required |
|:---------|:------------------|:----------------|:---------|
| `"gpio"` | Specifies GPIO pin to be used connected to `FAULT` driver line. | `"gpio"` | Yes |
| `"active_level"` | Active logical level that indicates fault. | "low" or "high" | Yes |
| `"action"` | Action to be taken if `FAULT` becomes active.  It is possible to "ignore" it, "stop" the motor or "stop_all" motors. | "ignore", "stop", "stop_all" | Yes |

Note, `"fault"` object is optional, however, if specified all values should be also specified.

## Customizing project

When JSON configuration file is written and ready, it is time to customize project. To do this execute the following command from project root directory:

```
./customize.sh <JSON configuration file>
```

Inspect the output for warnings and errors. If successful you may follow to the next [section](#Building-and-flashing-firmware). It is possible customizer will generate errors. Errors and warnings may have different nature, for example if JSON configuration file uses the same GPIO pin for different purposes, the error will be thrown. Possibly, you will have to refer to the MCU documentation in oreder to understand and fix them correctly.


## Building and flashing firmware

There are some scripts that will help you to build and flash firmware. Note, this scripts have some hard coded values which may be different to your build.

- `firmware/build.sh` - This script will build a debug version of firmware.
- `firmware/flash.sh` - This script will flash firmware to your MCU using `ST-LINK/V2 tools`.
- `software/build.sh` - This script will build a debug version of software.
- `gendox.sh` - Will generate documentation using Doxygen.

It is possible to flash and debug firmware using `OpenOCD` and `GDB`. There are many internet resources describing this possibility, sometimes this option is very useful, especially during heavy debugging.

Options to build and flash are not limited to these ones above. There are many other ways to do this job, I just mentioned most common way from my point of view.

## Linking with generated library

There are many ways to link generated library with main program. It worth to look how Home Lab Easy Kit monitor utility is linked with library. You may see it in software/CMakeLists.txt script.

## Contributing

Everyone is welcome to participate this project. Discuss changes you want to make with author first before doing pull request. I do not promise the answer will be quick, however I'll try to everyone.

Contribution may be made in several forms:
1. Testing. There were some testing, but it's not enough. I am certain there are bugs, I hope not much of them. Using the project and submitting issues will be very helpful.

2. Code review. This is my first open source project with STM32, and I understand lack of experience I have. So, it would be great if some one more experienced review this project, approaches I used, etc. Probably, this will result some features to be rewritten from the ground.

3. Documentation is very important. Currently documentation required to start work with the project is ready, however there are still many dark corners to be documented. Also, English is not my native language, so, fixing grammar, syntax mistakes is always good.

## Further development

There are a lot of ideas how to extend this project and move it forward. Among of others are:

1. Adding some new STM32 MCU support. This task will require a lot of development, therefor this new MCU must worth it. Priorities are: cheap, performance, features, microchips and demo boards availability on the market. I understand this is unrealistic, however STM32F103x shows, dreams sometimes get true.

2. Changing software interfaces. Interfaces to virtual devices are simple, however some of them may be changed to better. It is not a big deal to change them, more complex thing is how to provide them to be as much simple and convenient as possible.

3. Adding support to other peripherals. It could be both STM32F10x peripherals and other devices. STM32F103x provides a lot of features. For example, hardware PWM may be implemented - it will be less flexible than software PWM but won't load MCU. A good example of external device support is AD9851 DDS signal generator module.

## Contact

If you want to contact me you can reach me at oleh.sharuda@gmail.com

## License
```
Copyright 2021 Oleh Sharuda <oleh.sharuda@gmail.com>


Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```
