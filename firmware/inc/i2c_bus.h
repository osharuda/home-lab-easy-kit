/**
 *   Copyright 2021 Oleh Sharuda <oleh.sharuda@gmail.com>
 *
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/*!  \file
 *   \brief Header for communication protocol implementation over i2c bus.
 *   \author Oleh Sharuda
 */

#pragma once

#include <circbuffer.h>

/// \addtogroup group_communication
///  @{

/// \defgroup group_communication_virtual_device Virtual devices
/// \brief Details for virtual devices hosted by firmware
///  @{
/// \page page_communication_virtual_device
/// \tableofcontents
///
/// \section sect_communication_virtual_device_01 Virtual devices
/// Virtual devices implement some functionality and are entities software communicates with by communication protocol.
/// There are two types of virtual devices:
///     - Exclusive devices. There could be just one (or zero) exclusive device established by firmware. Examples are:
///         -# Info device
///         -# Desk device
///         -# GPIO device
///         -# IRRC device
///         -# LCD1602a device
///         -# RTC device
///         -# SPWM device
///     - Non-exclusive device. Firmware may host multiple non exclusive devices, they utilize different peripherals.
///       Examples are:
///         -# ADC device
///         -# UART proxy device
///         -# Stepper motor device
///
/// Each virtual is identified by device ID, an address that is used to work with device via communication protocol.
/// There are 16 virtual devices addresses available, however Info device with address 0 is mandatory device, so 15
/// virtual devices are available per firmware.
/// \section sect_communication_virtual_device_02 Details
/// All virtual device should allocate and initialize #tag_DeviceContext structure and call #comm_register_device()
/// in order to register itself for communication. Once done, communication will call specified device callbacks according
/// to protocol.
///
/// Non-exclusive virtual devices use device descriptors arrays generated by customizer. Every such device (of the same type)
/// has a personal index which value is an index of particular device in device description array(s). These arrays are device
/// specific, but it is important that non-exclusive device may access specific device data by index. This index ranges
/// from 0 to number of devices of the same type.
///
/// All non-exclusive virtual devices (of the same kind) have personal #tag_DeviceContext structure with different values
/// except callbacks. Internally, non-exclusive device callbacks get device index and thus may access specific device data.
///
/// All devices have three callbacks:
///      - tag_DeviceContext#on_command() - Command callback. It is used to pass a command to the device. Note, that
///        buffer being used by all devices for command data is shared (#g_recv_buffer, #COMM_BUFFER_LENGTH bytes in length)
///      - tag_DeviceContext#on_read_done() - Read callback. Notifies device that data from it's buffer is read by software.
///      - tag_DeviceContext#on_polling() - Device may schedule simple pooling with specified period of time. This callback
///        provide ability for device to be called periodically.
///
/// Device may have linear or circular buffer. Or may have none buffers if device accept commands only. Linear buffers
/// are suitable for devices that return constant length data like structures. Circular buffers could be used by devices
/// that accumulate data and software read that data from time to time. Note, circular buffers may be used for other than
/// device buffer purpose. For example stepper motor device uses circular buffers as internal buffer for stepper motor
/// commands.
///

/// \typedef ON_COMMAND
/// \brief Defines command callback function that virtual device uses in order to get commands from software side.
/// \param cmd_byte - command byte received from software. Corresponds to tag_CommCommandHeader#command_byte
/// \param data - pointer to data received
/// \param length - length of the received data.
typedef void (*ON_COMMAND)(uint8_t cmd_byte, uint8_t* data, uint16_t length);

/// \typedef ON_READDONE
/// \brief Defines command callback function that virtual device uses in order to get notifications that device's buffer
///        was read by software.
/// \param device_id - device id of the device whose data was read
/// \param length - length of the read (transmitted) data.
typedef void (*ON_READDONE)(uint8_t device_id, uint16_t length);

/// \typedef ON_POLLING
/// \brief Defines command callback function that virtual device uses to get periodically notified.
/// \param device_id - device id
typedef void (*ON_POLLING)(uint8_t device_id);

/// \struct tag_DeviceContext
/// \brief DeviceContext is used by communication in order to work with virtual device.
typedef __attribute__ ((aligned (8))) struct tag_DeviceContext {
    uint8_t device_id;                  ///< Device identifier, used by software to specify destination virtual device

    // device callbacks
    ON_COMMAND on_command;              ///< This callback is specified by virtual device.
                                        ///< It is called by communication when command is received. May be zero if not required.
    ON_READDONE on_read_done;           ///< This callback is specified by virtual device.
                                        ///< It is called by communication when software has read device buffer. May be zero if not required.
    ON_POLLING on_polling;              ///< This callback is specified by virtual device.
                                        ///< It is called by communication periodically when no communication happens.
                                        ///< Virtual device may use it to do some simple tasks. May be zero if not required.

    // buffer description
    uint16_t bytes_available;           ///< Specify amount of bytes available in virtual device buffer for read. May be zero.
    volatile uint8_t* buffer;           ///< Device linear buffer. May be zero if linear buffer is not used. If set to non-zero #circ_buffer must be zero
    volatile PCircBuffer circ_buffer;   ///< Specify circular buffer. If set to non-zero #buffer must be zero

    // pooling callback
    uint64_t polling_period;      ///< Specify polling period for on_polling callback (in micro seconds)
    uint64_t next_pooling_ev;		///< Used by communication part to calculate when on_polling() should be called for the next time
    uint16_t dev_index;			///< This field is used for non-exclusive devices to store device index.
    uint8_t next_pooling_ovrrun; 	                            ///< Used by communication part to indicate next_pooling_ev passed through the maximum value. With 64 bit counters added it is not possible. Deprecated.
} DeviceContext;

typedef DeviceContext *PDeviceContext;

/// \brief Virtual device calls this function in order to register device for communication with software
/// \param dev_ctx #tag_DeviceContext structure that describes the virtual device
void comm_register_device(PDeviceContext dev_ctx);

/// \brief Virtual device calls this function inside tag_DeviceContext#on_read_done to instruct communication that virtual device confirmed read
/// \param status - value to be set as communication status (read by software with tag_CommResponseHeader#comm_status)
void comm_done(uint8_t status);

/// \brief This command takes command byte and returns virtual device index for non-exclusive devices
/// \details Non-exclusive device may call #comm_register_device several times for several indexed device.
/// \details But all the callbacks in #tag_DeviceContext are the same, so callbacks should be able to get index of the device.
/// \details index of the device is read by virtual device code from tag_DeviceContext#dev_index
/// \param cmd_byte - command byte (tag_CommCommandHeader#command_byte) obtained through the communication from software
/// \returns #tag_DeviceContext for that specific indexed device
PDeviceContext comm_dev_context(uint8_t cmd_byte);
/// @}

/// \defgroup group_communication_i2c_impl I2C bus
/// \brief I2C implementation details
///  @{
/// \page page_communication_i2c_impl
/// \tableofcontents
///
/// \section sect_communication_i2c_impl_01 Intro
/// I2C bus is well known and widely used bus for electronic components communication. A lot of devices uses this bus in
/// order to exchange data. I2C allows (if wiring capacity limit is not exceeded) to unite many devices together.
/// The range of such devices varies widely from microchips, microcontrollers and modules to microcomputers.
///
/// All these good things make I2C bus is very suitable for this project purposes. It is possibly to connect a microcomputer
/// to microcontroller and use it's peripherals through this project. Also, it is possible to connect other devices by the same
/// bus at the very same time and use them separately. And all this require just two signal lines. What could be better?
///
/// \section sect_communication_i2c_impl_02 Caveats
/// There are several things worth to describe regarding I2C bus:
///      - Bus capacity. I2C wires capacity may not exceed some limit, otherwise data corruption may occur. This limit
///        depends on number of things, but it should be always be kept in mind. This project communication protocol support
///        control sum calculation, so software should be informed if data corruption takes place.
///      - Early Raspberry Pi models models have BCM2835 cpu on board. This processor has I2C clock-stretching bug. Thus,
///        this bug is present on these Raspberry Pi models and it's not possible to use clock stretching with them. This
///        limitation may be overcome by connecting devices that don't utilize clock stretching or by use software implementations
///        of I2C bus. This project implements I2C communication without use of clock stretching, so it can be used with early
///        Raspberry Pi models. Also, during the tests I have burned one of my Raspberry Pi's I2C pins due to improper power
///        connection. I've kept using that microcomputer but with i2c-gpio. There are number of instructions in internet
///        that will help you to setup i2c.
///      - Logical levels. This project uses 3.3v logic, so it doesn't require logic level convertor with Raspberry Pi.
///        If you want to connect other devices to the same bus or use it with another microcomputer always check if
///        logic levels is the same. If logical levels are different use corresponding level convertor.
///      - Addressing. This project uses 8-bit addressing mode. Firmware is configured as slave.
///      - I2C may work in different speed modes. My test hardware is setup for standard (100kHz) speed.


/// \def CHECK_SR1SR2_FLAGS
/// \brief Use this macro to check required status values read from I2C SR1 and SR2 registers (I2C_SR1_XXX and I2C_SR2_XXX in CMSIS library)
/// \param f - 32 bit value that represents SR1 (higher 16 bits) and SR2 (lower 16 bits) values
/// \param _sr1 - flag mask for SR1 (I2C_SR1_XXX from CMSIS library)
/// \param _sr2 - flag mask for SR2 (I2C_SR2_XXX from CMSIS library)
#define CHECK_SR1SR2_FLAGS(f, _sr1, _sr2) (((f) & (((_sr1) << 16) | (_sr2)))==(((_sr1) << 16) | (_sr2)))

/// \brief This function initializes I2C based communication. Must be called from #main() before registering any virtual devices with #comm_register_device()
void i2c_bus_init(void);

/// \brief This function is called in #main() infinite loop to check if command is received from the software and to
///        dispatch this command to corresponding virtual device handler. This function may call either
///        tag_DeviceContext#on_command or tag_DeviceContext#on_read_done
void i2c_check_command(void);

/// \brief This function is called in #main() infinite loop to check if tag_DeviceContext#on_polling should be called for
///        some device.
void i2c_pool_devices(void);

/// \brief This function re-initializes I2C communication peripherals in order to prepare communication for the next
///        receive/transmit from the software side
/// \note When this function is being executed I2C is not available and software may get failure in attempt to read/write
///       from I2C device. Thus, software should be prepared and treat such failures as #COMM_STATUS_BUSY
/// \note This function is called in the following situations:\n
///       - first initialization of I2C peripherals
///       - stop condition is received but command was not dispatched to corresponding virtual device (#g_cmd_type is #BUS_CMD_NONE)
///       - after virtual device tag_DeviceContext#on_command() is executed (#g_cmd_type is #BUS_CMD_WRITE)
///       - after virtual device tag_DeviceContext#on_read_done() is executed (#g_cmd_type is #BUS_CMD_READ)
void i2c_bus_reinit(void);

/// \brief This function initializes I2C communication when I2C peripherals receive address byte (I2C_SR1_ADDR flag).
///        It prepares communication for receive or transmit, it depends on parameters being passed.
/// \param transmit - non-zero if transmit operation. Zero for receive operation. Transmit is detected by I2C_SR1_TXE or
///        I2C_SR2_TRA flags from CMSIS library.
/// \param first_byte_sent - indicates that first byte is already sent (for transmit operation only)
/// \note Firmware must write first byte into data register as soon as possible, otherwise there is a risks software will
///       receive invalid data (device address will be received). Thus, if I2C_SR1_TXE flag indicates empty data register,
///       it should be filled immediately, and all other initialization must be accomplished later in i2c_addr_init() call.
///       first_byte_sent parameter is required in order to initialize internal data correctly
void i2c_addr_init(uint8_t transmit, uint8_t first_byte_sent);

/// \brief This function allows to write some value that belongs to I2C communication implementation from #main() infinite
///        loop context synchronously.
/// \param v - pointer to value to be set.
/// \param nv - new value to be set
/// \details This function is required in order to set #g_cmd_type safely from #main() infinite loop. This variable shouldn't
///          be set if I2C communication is ongoing. Ongoing communication is specified by #g_i2c_busy variable, thus
///          this function check it in order to write safely. Also this function disables interrupts for synchronous operation.
/// \warning This function disables interrupts with #DISABLE_IRQ macro. #DISABLE_IRQ may not be used recursively, thus don't
///          use this function when interrupts are disabled.
void i2c_set_sync(volatile uint8_t* v, uint8_t nv);

/// \brief This function is called from I2C event interrupt handler to handle receive of new byte from master (software).
void i2c_receive_byte(void);

/// \brief This function is called from I2C event interrupt handler to send a byte to master (software).
void i2c_transmit_byte(void);

/// \brief This function is called from I2C event and error interrupt handlers to stop I2C bus communication with master (software)
void i2c_stop(void);

/// @}

/// @}
