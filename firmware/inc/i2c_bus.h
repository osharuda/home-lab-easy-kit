/**
 *   Copyright 2021 Oleh Sharuda <oleh.sharuda@gmail.com>
 *
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/*!  \file
 *   \brief Header for communication protocol implementation over i2c bus.
 *   \author Oleh Sharuda
 */

#pragma once

#include <circbuffer.h>

/// \addtogroup group_communication
///  @{

/// \defgroup group_communication_virtual_device Virtual devices
/// \brief Details for virtual devices hosted by firmware
///  @{
/// \page page_communication_virtual_device
/// \tableofcontents
///
/// \section sect_communication_virtual_device_01 Virtual devices
/// Virtual devices implement some functionality and are entities software communicates with by communication protocol.
/// There are two types of virtual devices:
///     - Exclusive devices. There could be just one (or zero) exclusive device established by firmware. Examples are:
///         -# Info device
///         -# Desk device
///         -# GPIO device
///         -# IRRC device
///         -# LCD1602a device
///         -# RTC device
///         -# SPWM device
///     - Non-exclusive device. Firmware may host multiple non exclusive devices, they utilize different peripherals.
///       Examples are:
///         -# ADC device
///         -# UART proxy device
///         -# Stepper motor device
///
/// Each virtual is identified by device ID, an address that is used to work with device via communication protocol.
/// There are 16 virtual devices addresses available, however Info device with address 0 is mandatory device, so 15
/// virtual devices are available per firmware.
/// \section sect_communication_virtual_device_02 Details
/// All virtual device should allocate and initialize #tag_DeviceContext structure and call #comm_register_device()
/// in order to register itself for communication. Once done, communication will call specified device callbacks according
/// to protocol.
///
/// Non-exclusive virtual devices use device descriptors arrays generated by customizer. Every such device (of the same type)
/// has a personal index which value is an index of particular device in device description array(s). These arrays are device
/// specific, but it is important that non-exclusive device may access specific device data by index. This index ranges
/// from 0 to number of devices of the same type.
///
/// All non-exclusive virtual devices (of the same kind) have personal #tag_DeviceContext structure with different values
/// except callbacks. Internally, non-exclusive device callbacks get device index and thus may access specific device data.
///
/// All devices have three callbacks:
///      - tag_DeviceContext#on_command() - Command callback. It is used to pass a command to the device. Note, that
///        buffer being used by all devices for command data is shared (#g_recv_buffer, #COMM_BUFFER_LENGTH bytes in length)
///      - tag_DeviceContext#on_read_done() - Read callback. Notifies device that data from it's buffer is read by software.
///      - tag_DeviceContext#on_polling() - Device may schedule simple pooling with specified period of time. This callback
///        provide ability for device to be called periodically.
///
/// Device may have linear or circular buffer. Or may have none buffers if device accept commands only. Linear buffers
/// are suitable for devices that return constant length data like structures. Circular buffers could be used by devices
/// that accumulate data and software read that data from time to time. Note, circular buffers may be used for other than
/// device buffer purpose. For example stepper motor device uses circular buffers as internal buffer for stepper motor
/// commands.
///

/// \typedef ON_COMMAND
/// \brief Defines command callback function that virtual device povides to execute it's commands, sent by from software.
/// \param cmd_byte - command byte received from software. Corresponds to CommCommandHeader#command_byte
/// \param data - pointer to data received
/// \param length - length of the received data.
/// \return Updated device status (later synchronously copied to g_comm_status)
typedef uint8_t (*ON_COMMAND)(uint8_t cmd_byte, uint8_t* data, uint16_t length);

/// \typedef ON_READDONE
/// \brief Defines command callback function virtual device provides to complete data read from it's buffer.
/// \param device_id - device id of the device whose data was read
/// \param length - length of the read (transmitted) data.
/// \return Updated device status (later synchronously copied to g_comm_status)
typedef uint8_t (*ON_READDONE)(uint8_t device_id, uint16_t length);

/// \typedef ON_POLLING
/// \brief Defines command callback function that virtual device uses to get periodically notified.
/// \param device_id - device id
typedef void (*ON_POLLING)(uint8_t device_id);

/// \struct tag_DeviceContext
/// \brief DeviceContext is used by communication in order to work with virtual device.
struct __attribute__ ((aligned (8))) DeviceContext {
    uint64_t polling_period;    ///< Specify polling period for on_polling callback (in micro seconds)

    uint64_t next_pooling_ev;	///< Used by communication part to calculate when on_polling() should be called for the next time

    // device callbacks
    ON_COMMAND on_command;              ///< This callback is specified by virtual device.
                                        ///< It is called by communication when command is received. May be zero if not required.

    ON_READDONE on_read_done;           ///< This callback is specified by virtual device.
                                        ///< It is called by communication when software has read device buffer. May be zero if not required.

    ON_POLLING on_polling;              ///< This callback is specified by virtual device.
                                        ///< It is called by communication periodically when no communication happens.
                                        ///< Virtual device may use it to do some simple tasks. May be zero if not required.

    uint8_t* buffer;                    ///< Device linear buffer. May be zero if linear buffer is not used. If set to non-zero #circ_buffer must be zero

    struct CircBuffer* circ_buffer;     ///< Specify circular buffer. If set to non-zero #buffer must be zero

    uint16_t dev_index;			        ///< This field is used for non-exclusive devices to store device index.

    uint16_t bytes_available;           ///< Specify amount of bytes available in liniar virtual device buffer for read. May be zero.
                                        ///< Ignored in the case of cicular buffer.

    uint8_t device_id;                  ///< Device identifier, used by software to specify destination virtual device

    uint8_t next_pooling_ovrrun; 	    ///< Used by communication part to indicate next_pooling_ev passed through the maximum value. With 64 bit counters added it is not possible. Deprecated.

    uint8_t i2c_circular_buffer;        ///< 0 if linear buffer, 1 if circular buffer. Note these two values must be identical to the
                                        ///< i2c bus finite state machine values (
};

/// \brief Virtual device calls this function in order to register device for communication with software
/// \param dev_ctx #tag_DeviceContext structure that describes the virtual device
void comm_register_device(struct DeviceContext* dev_ctx);

/// \brief This command takes command byte and returns virtual device index for non-exclusive devices
/// \details Non-exclusive device may call #comm_register_device several times for several indexed device.
/// \details But all the callbacks in #tag_DeviceContext are the same, so callbacks should be able to get index of the device.
/// \details index of the device is read by virtual device code from tag_DeviceContext#dev_index
/// \param cmd_byte - command byte (CommCommandHeader#command_byte) obtained through the communication from software
/// \returns #tag_DeviceContext for that specific indexed device
struct DeviceContext* comm_dev_context(uint8_t cmd_byte);
/// @}

/// \defgroup group_communication_i2c_impl I2C bus
/// \brief I2C implementation details
///  @{
/// \page page_communication_i2c_impl
/// \tableofcontents
///
/// \section sect_communication_i2c_impl_01 Intro
/// I2C bus is well known and widely used bus for electronic components communication. A lot of devices uses this bus in
/// order to exchange data. I2C allows (if wiring capacity limit is not exceeded) to unite many devices together.
/// The range of such devices varies widely from microchips, microcontrollers and modules to microcomputers.
///
/// All these good things make I2C bus is very suitable for this project purposes. It is possibly to connect a microcomputer
/// to microcontroller and use it's peripherals through this project. Also, it is possible to connect other devices by the same
/// bus at the very same time and use them separately. And all this require just two signal lines. What could be better?
///
/// \section sect_communication_i2c_impl_02 Caveats
/// There are several things worth to describe regarding I2C bus:
///      - Bus capacity. I2C wires capacity may not exceed some limit, otherwise data corruption may occur. This limit
///        depends on number of things, but it should be always be kept in mind. This project communication protocol support
///        control sum calculation, so software should be informed if data corruption takes place.
///      - Early Raspberry Pi models models have BCM2835 cpu on board. This processor has I2C clock-stretching bug. Thus,
///        this bug is present on these Raspberry Pi models and it's not possible to use clock stretching with them. This
///        limitation may be overcome by connecting devices that don't utilize clock stretching or by use software implementations
///        of I2C bus. This project implements I2C communication without use of clock stretching, so it can be used with early
///        Raspberry Pi models. Also, during the tests I have burned one of my Raspberry Pi's I2C pins due to improper power
///        connection. I've kept using that microcomputer but with i2c-gpio. There are number of instructions in internet
///        that will help you to setup i2c.
///      - Logical levels. This project uses 3.3v logic, so it doesn't require logic level convertor with Raspberry Pi.
///        If you want to connect other devices to the same bus or use it with another microcomputer always check if
///        logic levels is the same. If logical levels are different use corresponding level convertor.
///      - Addressing. This project uses 8-bit addressing mode. Firmware is configured as slave.
///      - I2C may work in different speed modes. My test hardware is setup for standard (100kHz) speed.


/// \def TEST_SR1SR2_FLAGS
/// \brief Use this macro to check required status values read from I2C SR1 and SR2 registers (I2C_SR1_XXX and I2C_SR2_XXX in CMSIS library)
/// \param f - 32 bit value that represents SR1 (higher 16 bits) and SR2 (lower 16 bits) values
/// \param _sr1 - flag mask for SR1 (I2C_SR1_XXX from CMSIS library)
/// \param _sr2 - flag mask for SR2 (I2C_SR2_XXX from CMSIS library)
#define TEST_SR1SR2_FLAGS(f, _sr1, _sr2) (((f) & (((_sr1) << 16) | (_sr2)))==(((_sr1) << 16) | (_sr2)))


/// \brief This function initializes I2C based communication. Must be called from #main() before registering any virtual devices with #comm_register_device()
void i2c_bus_init(void);

/// \brief This function is called in #main() infinite loop to check if command is received from the software and to
///        dispatch this command to corresponding virtual device handler. This function may call either
///        tag_DeviceContext#on_command or tag_DeviceContext#on_read_done
void i2c_check_command(void);

/// \brief This function is called in #main() infinite loop to check if tag_DeviceContext#on_polling should be called for
///        some device.
void i2c_pool_devices(void);
/// @}

/// @}
