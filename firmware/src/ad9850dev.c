/**
 *   Copyright 2021 Oleh Sharuda <oleh.sharuda@gmail.com>
 *
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/*!  \file
 *   \brief AD9850Dev device C source file.
 *   \author Oleh Sharuda
 */

#include <string.h>
#include "fw.h"
#include "utools.h"
#include "i2c_bus.h"
#include "ad9850dev.h"
#include <stm32f10x.h>
#include <core_cm3.h>


#ifdef AD9850DEV_DEVICE_ENABLED

/// \addtogroup group_ad9850dev
/// @{

/// \brief Add implementations for autogenerated functions to set D0-D7 lines
AD9850DEV_FW_SET_DATA_FUNCTIONS

/// \brief Global array that stores all virtual AD9850Dev devices configurations.
volatile AD9850DevInstance g_ad9850dev_devs[] = AD9850DEV_FW_DEV_DESCRIPTOR;

/// @}

//---------------------------- FORWARD DECLARATIONS ----------------------------

/// \brief Reset AD9850 leaving it in power down mode.
/// \param dev - AD9850 instance definition structure.
void ad9850dev_reset(volatile AD9850DevInstance* dev);

/// \brief Updates AD9850 frequency, phase and power down mode.
/// \param dev - AD9850 instance definition structure.
void ad9850dev_update(volatile AD9850DevInstance* dev);

void ad9850dev_init_vdev(volatile AD9850DevInstance* dev, uint16_t index) {
    volatile PDeviceContext devctx = (volatile PDeviceContext)&(dev->dev_ctx);
    memset((void*)devctx, 0, sizeof(DeviceContext));
    PAD9850Command cmd = &(dev->privdata.command);
    START_PIN_DECLARATION;

    devctx->device_id    = dev->dev_id;
    devctx->dev_index    = index;
    devctx->on_command   = ad9850dev_execute;
    devctx->on_read_done = ad9850dev_read_done;
    devctx->buffer = (volatile uint8_t*) &(dev->privdata.command);
    devctx->bytes_available = sizeof(AD9850DevPrivData);

    comm_register_device(devctx);

    // Register GPIO
    DECLARE_PIN(dev->D0_port, dev->D0_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D0_port, dev->D0_pin_mask);

    DECLARE_PIN(dev->D1_port, dev->D1_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D1_port, dev->D1_pin_mask);

    DECLARE_PIN(dev->D2_port, dev->D2_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D2_port, dev->D2_pin_mask);

    DECLARE_PIN(dev->D3_port, dev->D3_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D3_port, dev->D3_pin_mask);

    DECLARE_PIN(dev->D4_port, dev->D4_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D4_port, dev->D4_pin_mask);

    DECLARE_PIN(dev->D5_port, dev->D5_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D5_port, dev->D5_pin_mask);

    DECLARE_PIN(dev->D6_port, dev->D6_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D6_port, dev->D6_pin_mask);

    DECLARE_PIN(dev->D7_port, dev->D7_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->D7_port, dev->D7_pin_mask);

    DECLARE_PIN(dev->RESET_port, dev->RESET_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->RESET_port, dev->RESET_pin_mask);

    DECLARE_PIN(dev->W_CLK_port, dev->W_CLK_pin_mask, GPIO_Mode_Out_PP);
    GPIO_ResetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);

    DECLARE_PIN(dev->FQ_UD_port, dev->FQ_UD_pin_mask, GPIO_Mode_Out_PP);
    GPIO_SetBits(dev->FQ_UD_port, dev->FQ_UD_pin_mask);

    // Register GPIO
    ad9850dev_reset(dev);

    // Set default state
    cmd->freq_b31_b24 = 0;
    cmd->freq_b23_b16 = 0;
    cmd->freq_b15_b8 = 0;
    cmd->freq_b7_b0 = 0;

    cmd->phase = 0;
    cmd->control = 0;
    cmd->power_down = 1; // Default mode is power down
    ad9850dev_update(dev);
}

void ad9850dev_reset(volatile AD9850DevInstance* dev) {
    // Pulse reset
    GPIO_SetBits(dev->RESET_port, dev->RESET_pin_mask);
    // Documentation says reset duration should be at least 5 clock cycles.
    __NOP();
    __NOP();
    __NOP();
    __NOP();
    __NOP();
    GPIO_ResetBits(dev->RESET_port, dev->RESET_pin_mask);
}

void ad9850dev_update(volatile AD9850DevInstance* dev) {
    PAD9850Command cmd = &(dev->privdata.command);
    assert_param(sizeof(AD9850Command)==5);

    // FQ_UD <- LOW
    GPIO_ResetBits(dev->FQ_UD_port, dev->FQ_UD_pin_mask);

    // Put byte 0
    dev->p_set_gpio_data(cmd->W0);
    GPIO_SetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);
    GPIO_ResetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);

    // Put byte 1
    dev->p_set_gpio_data(cmd->freq_b31_b24);
    GPIO_SetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);
    GPIO_ResetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);

    // Put byte 2
    dev->p_set_gpio_data(cmd->freq_b23_b16);
    GPIO_SetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);
    GPIO_ResetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);

    // Put byte 3
    dev->p_set_gpio_data(cmd->freq_b15_b8);
    GPIO_SetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);
    GPIO_ResetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);

    // Put byte 4
    dev->p_set_gpio_data(cmd->freq_b7_b0);
    GPIO_SetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);
    GPIO_ResetBits(dev->W_CLK_port, dev->W_CLK_pin_mask);

    // FQ_UD <- HI
    GPIO_SetBits(dev->FQ_UD_port, dev->FQ_UD_pin_mask);
}

void ad9850dev_init() {
    for (uint16_t i=0; i<AD9850DEV_DEVICE_COUNT; i++) {
        volatile AD9850DevInstance* dev = (volatile AD9850DevInstance*)g_ad9850dev_devs+i;
        ad9850dev_init_vdev(dev, i);
    }
}

void ad9850dev_execute(uint8_t cmd_byte, uint8_t* data, uint16_t length) {
    uint8_t status = COMM_STATUS_FAIL;
    volatile PDeviceContext devctx = comm_dev_context(cmd_byte);
    volatile AD9850DevInstance* dev = (volatile AD9850DevInstance*)g_ad9850dev_devs + devctx->dev_index;
    PAD9850Command cmd = &(dev->privdata.command);

    if (length!=sizeof(AD9850Command)) {
        goto done;
    }

    memcpy((void*)cmd, data, sizeof(AD9850Command));
    cmd->control = 0;   // Make sure this field is not 1 or 2

    if (IS_SET(cmd_byte, AD9850DEV_RESET)) {
        ad9850dev_reset(dev);
    }

    ad9850dev_update(dev);

    status = COMM_STATUS_OK;
done:
    comm_done(status);
}

void ad9850dev_read_done(uint8_t device_id, uint16_t length) {
    UNUSED(device_id);
    UNUSED(length);
    comm_done(0);
}

#endif
